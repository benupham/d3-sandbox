<!DOCTYPE html>
<meta charset="utf-8">
<title>Clustered Force Layout</title>
<body>
  <!-- <svg id="circle-svg" width="960" height="960"></svg> -->
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="https://unpkg.com/d3-force-attract@latest"></script>
<script src="https://unpkg.com/d3-force-cluster@latest"></script>
<script>

var width = 960,
    height = 500,
    maxRadius = 12;
    padding = 0, // separation between same-color nodes
    clusterPadding = 0; // separation between different-color nodes

var color = d3.scaleOrdinal(d3.schemeCategory20)
    .domain(d3.range(20));


d3.json("./data/testd3dataNoSalesDept.json", function(error, root) {
  console.log('og root',root)
  var pack = d3.pack()
    .size([(width), (height)])
    .padding(2);  

  root = d3.hierarchy(root)
      .sum(function(d) { return d.size; })
      .sort(function(a, b) { return b.value - a.value; });
      console.log('root',root);
      console.log('the pack',pack(root))
  var thePack = pack(root);  

  var depts = [];
  var subdepts = [];
  var brands = [];

  thePack.children.forEach(d => {
    d.type = 'department';
    depts.push(d);
    d.children.forEach(sd => {
      sd.type = 'subdepartment';
      subdepts.push(sd);
      sd.children.forEach(b => {
        b.type = 'brand';
        brands.push(b);
      })
    });
  });

  console.log('depts',depts[0])

  // The largest node for each group: depts, subdepts, brands and products.
  // Labeled with their parent's name. 
  var clustersObj = {};
  
  function createClusteredNode (d) {
    var id = d.data.id,
        data = d.data,
        dept = d.parent.data.name,
        type = d.type,
        r = d.r,
        n = {cluster: dept, radius: r, x: d.x, y: d.y, id: id, type: type, data: data};
    if (!clustersObj[dept] || (r > clustersObj[dept].radius)) clustersObj[dept] = n;
    return n;
  }



  var nodes = depts.map( d=> createClusteredNode(d));


  var simulation = d3.forceSimulation()
    // keep entire simulation balanced around screen center
    .force('center', d3.forceCenter(width/2, height/2))
    
    // pull toward center
    .force('attract', d3.forceAttract()
      .target([width/2, height/2])
      .strength(0.01))

    // cluster by section
    .force('cluster', d3.forceCluster()
      .centers(function (d) { return clustersObj[d.cluster]; })
      .strength(0.5)
      .centerInertia(0.1))

    // apply collision with padding
    .force('collide', d3.forceCollide(function (d) { return d.radius + padding; })
      .strength(0))

    .on('tick', layoutTick)
    .nodes(nodes);
    
  var svg = d3.select('body').append('svg')
      .attr('width', width)
      .attr('height', height);

  var node = svg.selectAll('circle')
    .data(nodes)
    .enter().append('circle')
      .style('fill', function (d) { return 'blue'; })
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended)
      )
      .on('click', click);

  function dragstarted (d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged (d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended (d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  function click(d) {
    console.log(d);
    let newNodes = []; 
    if (d.type == 'department') {
      newNodes = subdepts.filter(sd => sd.parent.data.id == d.id)
      console.log('newNodes',newNodes)
    } else if (d.type == 'subdepartment') {

    } else if (d.type == 'brand') {

    }
    console.log(nodes)
    newNodes.forEach(n => {
      nodes.push(createClusteredNode(n));
      
    });
    console.log(nodes)
    console.log(node)
    simulation.nodes(nodes);
    console.log(simulation.nodes())
    console.log(node)
  }

  // ramp up collision strength to provide smooth transition
  var transitionTime = 3000;
  var t = d3.timer(function (elapsed) {
    var dt = elapsed / transitionTime;
    simulation.force('collide').strength(Math.pow(dt, 2) * 0.7);
    if (dt >= 1.0) t.stop();
  });
    
  function layoutTick (e) {
    node
      .attr('cx', function (d) { return d.x; })
      .attr('cy', function (d) { return d.y; })
      .attr('r', function (d) { return d.radius; });
  }


})




</script>
</body>
</html>