<!DOCTYPE html>
<meta charset="utf-8">
<title>Clustered Force Layout</title>
<body>
  <!-- <svg id="circle-svg" width="960" height="960"></svg> -->
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="https://unpkg.com/d3-force-attract@latest"></script>
<script src="https://unpkg.com/d3-force-cluster@latest"></script>
<script>

var width = 960,
    height = 500,
    maxRadius = 12,
    scale = 1,
    zoomWidth = (width-scale*width)/2,
    zoomHeight = (height-scale*height)/2,
    padding = 1, // separation between same-color nodes
    clusterPadding = 0; // separation between different-color nodes

var zoom = d3.zoom()
  .scaleExtent([0.01,10])
  .on("zoom", zoomed);  

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height)
  .call(zoom)
  .append("g")
  .attr("transform", "translate(" + zoomWidth + "," + zoomHeight + ") scale(" + scale + ")");
    

var color = d3.scaleOrdinal(d3.schemeCategory20)
    .domain(d3.range(20));


d3.json("./data/testd3dataNoSalesDept.json", function(error, root) {
  
  var pack = d3.pack()
    .size([(width), (height)])
    .padding(2);  

  root = d3.hierarchy(root)
      .sum(function(d) { return d.size; })
      .sort(function(a, b) { return b.value - a.value; });
     
  var thePack = pack(root);  

  var depts = [];
  var subdepts = [];
  var brands = [];

  thePack.children.forEach(d => {
    d.type = 'department';
    depts.push(d);
    d.children.forEach(sd => {
      sd.type = 'subdepartment';
      subdepts.push(sd);
      sd.children.forEach(b => {
        b.type = 'brand';
        brands.push(b);
      })
    });
  });


  // The largest node for each group: depts, subdepts, brands and products.
  // Labeled with their parent's name. 
  var clustersObj = {};
  
  function createClusteredNode (d) {
    var id = d.data.id,
        data = d.data,
        parent = d.parent.data.name,
        type = d.type,
        r = d.r,
        n = {cluster: parent, radius: 20, x: d.x, y: d.y, id: id, type: type, data: data};
    if (!clustersObj[parent] || (r > clustersObj[parent].radius)) clustersObj[parent] = n;
    return n;
  }

  var nodes = depts.map( d=> createClusteredNode(d));

  var simulation = d3.forceSimulation(nodes)
    // keep entire simulation balanced around screen center
    .force('center', d3.forceCenter(width/2, height/2))
    
    // pull toward center
    .force('attract', d3.forceAttract()
      .target([width/2, height/2])
      .strength(0.01))

    // cluster by section
    .force('cluster', d3.forceCluster()
      .centers(function (d) { return clustersObj[d.cluster]; })
      .strength(0.5)
      .centerInertia(0.1))

    // apply collision with padding
    .force('collide', d3.forceCollide(function (d) { return d.radius + padding; })
      .strength(0))
    
    .on('tick', layoutTick);  

  var node = svg.selectAll('circle');  

  // Start or restart     
  function update() {

    node = node.data(nodes, function(d) { return d.id;});
    
    node.exit().remove();
    
    node = node.enter()
        .append('circle')      
        .style('fill', function (d) { 
          return d.type === 'department' ? 'blue' : 
                 d.type === 'subdepartment' ? 'yellow' : d.type === 'brand' ? 'green' : 'red'; })
        .merge(node)
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended)
        )
        .on('click', click);

    simulation.nodes(nodes)
    simulation.alpha(0.7).restart();
  }  

  function layoutTick (e) {
      node
        .attr('cx', function (d) { return d.x; })
        .attr('cy', function (d) { return d.y; })
        .attr('r', function (d) { return d.radius; });
  }

  function dragstarted (d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged (d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended (d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
      
  function click(d) {
    let newNodes = []; 
    if (d.type == 'department') {
      newNodes = subdepts.filter(sd => sd.parent.data.id == d.id)
    } else if (d.type == 'subdepartment') {
      newNodes = brands.filter(b => b.parent.data.id == d.id)
    } else if (d.type == 'brand') {
      newNodes = products.filter(p => p.parent.data.id == d.id)
    }
    console.log(d)

    // Remove the clicked parent node
    for( var i = 0; i < nodes.length; i++){ 
      if ( nodes[i].id === d.id) {
        const removedNode = nodes.splice(i, 1)[0];
        console.log(removedNode)
        // If the clicked node was the biggest in its cluster, find 2nd biggest
        if (clustersObj[removedNode.cluster] === removedNode) {
          clustersObj[removedNode.cluster] = null; 
          nodes.forEach(n => {
            if (n.cluster === removedNode.cluster && (!clustersObj[removedNode.cluster] || n.radius > clustersObj[removedNode.cluster].radius)) 
            {
              clustersObj[removedNode.cluster] = n;
            }
          })
        }
      }
    }
    
    // Set location of entering nodes around position of parent node
    // Set a timer, then update for each
    newNodes.forEach((n,i) => {
      d3.timeout(function() {
        n.x = d.x + Math.random() * 10;
        n.y = d.y + Math.random() * 10;
        nodes.push(createClusteredNode(n));   
        update()
      }, 75 * i)
    });
  }

  // ramp up collision strength to provide smooth transition
  var transitionTime = 3000;
  var t = d3.timer(function (elapsed) {
    var dt = elapsed / transitionTime;
    simulation.force('collide').strength(Math.pow(dt, 2) * 0.7);
    if (dt >= 1.0) t.stop();
  });
    


  update();

})

function zoomed() {
    svg.attr("transform", d3.event.transform);
  }  


</script>
</body>
</html>